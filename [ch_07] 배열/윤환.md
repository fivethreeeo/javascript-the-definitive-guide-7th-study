# 7장 배열

배열은 값의 순서 있는 집합

배열 요소에 객체나 다른 배열을 써도 상관없음

자바스크립트 배열은 동적

필요한 만큼 커지거나 작아질 수 있고, 

배열을 생성할 때 고정된 크기를 선언하거나 크기가 변할 때 배열을 재 할당할 필요 없음

배열은 Array.prototype에서 프로퍼티를 상속

# **7.1** 배열 생성

## **7.1.1** 배열 리터럴

배열을 만드는 가장 단순한 방법은 배열 리터럴

```jsx
let empty = []; // 요소가 없는 배열
let primes= [2,3,5,7,11]; //숫자요소가다섯개있는배열
let misc = [ 1.1, true, "a", ]; // 타입이 다른 요소가 세 개 있고 콤마로 끝난 배열
```

배열 리터럴에 콤마를 연속해서 썼는데 그 사이에 값이 없으면 성긴 배열 생성

```jsx
let count = [1,,3]; // 인덱스 0과 2에는 요소가 있지만 인덱스 1에는 요소가 없습니다. 
let undefs =[,,] // 요소가 없지만 길이가 2인 배열
```

## **7.1.2** 분해 연산자

ES6 이후에는 분해 연산자 ...를 써서 배열 리터럴 안에 다른 배열 요소를 넣을 수 있음

분해 연산자는 배열을 얕게 (shallow) 복사할 때도 유용

```jsx
leta= [1, 2, 3];
letb=[0,...a,4]; //b==[0,1,2,3,4]
```

분해 연산자는 모든 이터러블 객체에 동작

## **7.1.3 Array()** 생성자

Array() 생성자를 써서 배열 생성 가능

```jsx
//인자 없이 호출
let a = new Array();

//배열길이를 나타내는 숫자 인자 하나로 호출
let a = new Array(10);

//배열요소를 두개 이상 쓰거나 숫자가 아닌 요소를 하나만 넘겨 호출
let a = new Array(5, 4, 3, 2, 1, "testing, testing");
```

## **7.1.4 Array.of()**

인자의 개수를 따지 지 않고 각 인자를 새 배열의 요소 사용

```jsx
Array.of() // => []; 인자가 없으므로 빈 배열
Array.of(10) // => [10]; 숫자 인자 하나만 있어도 됩니다.
Array.of(1,2,3)// => [1, 2, 3]
```

## **7.1.5 Array.from()**

첫 번째 인자로 이터러블 객체나 배열 비슷한 객체를 받으며, 해당 객체의 요소로 새 배열을 만들어 반환

```jsx
let copy = Array.from(original);
```

# **7.2** 배열 요소 읽기와 쓰기

배열 요소에 접근할 때는 [] 연산자를 사용

배열은 특별하긴 하지만 결국 객체

배열 요소에 접근할 때 사용하는 대괄호는 객체 프로퍼티에 접근할 때 사용하는 대괄호와 마찬가지로 동작

(인덱스를 숫자에서 문자열로 변환하여 인식)

# **7.3** 성긴 배열

성긴 배열은 인덱스가 연속적이지 않은 배열

성긴 배열의 경우 length 프로퍼티의 값이 요소 개수보다 큼

```jsx
let a = new Array(5); // 요소가 없지만 a.length는 5입니다.
a = []; // 요소가 없고 length가 0인 배열
a[1000] = 0; // 요소는 하나를 추가하지만 길이는 1001로 만드는 할당
```

[1,,3]처럼 배열 리터럴에 콤마를 반복하면 성긴 배열이 만들어지고, 생략된 요소는 존재하지 않습니다.

```jsx
let al= [,]; //이배열은요소가없고길이는1입니다.
let a2 = [undefined]; // o| 배열에는 undefined 요소가 하나 있습니다.
0 in al // => false: al은 인덱스 0에 요소가 없습니다.
0 in a2 // => true: a2는 인덱스 0에 undefined 값이 있습니다.
```

# **7.4** 배열 길이

모든 배열에는 length 프로퍼티가 있으며,

그 값은 배열에서 가장 큰 인덱스에 1을 더한 값

```jsx
a = [1,2,3,4,5]; // 요소가 다섯 개 있는 배열로 시작합니다. 
a.length = 3; // a는 이제 [1,2,3]입니다.
a.length = 0; // 요소 전체를 삭제합니다. a는 []입니다.
a.length = 5;// 길이는 5이지만 new Array(5)와 마찬가지로 요소는 없습니다.
```

# **7.5** 배열 요소 추가와 삭제

push() 메서드는 배 열 마지막에 값을 추가

unshift() 메서드를 써서 배열의 맨 앞에 값을 삽입

pop() 메서드는 push()의 반대로 배열의 마지막 요소를 제거하고 그 값을 반환하며 배열의 길이를 1만큼 줄입

shift() 메서드는 배열의 첫 번째 요소를 제 거해 반환하며 길이를 1만큼 줄이고 나머지 요소를 모두 앞으로 당김

## **7.6** 배열 순회

for/of 루프가 사용하는 내장 이터레이터는 

오름차순으로 요소를 반환

for/of 루프를 적용할 때 각 요소의 인덱스가 필요하다면 

다음과 같이 entries() 메서드와 분해 할당을 이용

```jsx
let everyother =''
for(let [index, letter] of letters.entries()) {
if (index % 2 === 0) everyother += letter; // 짝수 번째 인덱스의 글자 }
everyother // => "Hlowrd"
```

forEach()도 배열을 순회하는 좋은 방법

```jsx
let uppercase =
letters.forEach(letter => { // 화살표 함수 문법을 썼습니다.
uppercase += letter.tollpperCase(); });
uppercase // =그 ’’HELLO WORLD"
```

# **7.7** 다차원 배열

자바스크립트에서 다차원 배열을 직접 지원하지는 않지만,

배열의 배열을 만들어 대략적으로 흉내 가능

```jsx
// 다차원 배열을 생성합니다.
let table = new Array(10); // 배열 초기화
for(let i = 0; i < table.length; i++) {// 테이블 행은 10개입니다.
	table [i] = new Array(10); // 각 행에는 열이 10개씩 있습니다.
}

```

# **7.8** 배열 메서드

## **7.8.1** 배열 이터레이터 메서드

### **forEach()**

배열을 순회하며 각 요소에서 함수를 호출

배열 요소의 값, 배열 요소 의 인덱스, 배열 자체를 인자로 전달해 이 함수를 호출

### **map()**

각 배열 요소를 함수에 전달해 호출하며, 

그 함수가 반환한 값으로 이루어진 배열을 반환

```jsx
let a = [1, 2, 3];
a.map(x => x*x) // => [1, 4, 9]: 함수는 x를 받아 x*x를 반환합니다.
```

### **filter()**

기존 배열의 일부만 포함하는 부분 집합을 반환

전달하는 함수를 기준으로 하며 이 함수는 true 또는 faIse를 반환

```jsx
let a= [5, 4, 3, 2, 1];
a.filter(x=>x<3) //=> [2, 1]; 3미만인 값 
a.filter((x,i) => i%2 === 0) // => [5, 3, 1]; 인덱스가 짝수인 값
```

### **find()**와 **findlndex()**

find()와 findlndex() 메서드는 판별 함수에서 

true 같은 값을 반환하는 요소를 찾아 배열을 순회한다는 점은 filter()와 같지만, 기준을 만족하는 첫 번째 요소를 찾는 즉시 순회를 멈춤

요소를 찾지 못하면 find()는 undefined를, findlndex()는 -1을 반환

```jsx
let a = [1,2,3,4,5];
a.findlndex(x => x === 3) // => 2; 값 3은 인덱스 2에 있습니다.
a.findlndex(x => x < 0) // => -1; 배열에는 음수가 없습니다.
a.find(x => x % 5 === 0) // => 5: 5의 배수입니다.
a.find(x => x % 7 === 0)// => undefined: 이 배열에는 7의 배수가 없습니다.
```

### **every()와 some()**

****
every()와 some() 메서드는 배열 요소에 판별 함수를 적용하고 결과에 따라 true 또는 false를 반환

every() 메서드는 판별 함수가 배열의 모든 요소에 대해 true를 반환할 때만 true를 반환

```jsx
let a = [1,2,3,4,5];
a.every(x => x < 10) // => true: 모든 값이 10 미만입니다. 
a.every(x => x % 2 === 0) // => false: 짝수가 아닌 값이 있습니다.
```

### **reduce()와 reduceRight()**

reduce()와 reduceRight() 메서드는 제공하는 함수를 

사용해 배열 요소를 값 하나로 만듦

```jsx
let a = [1,2,3,4,5];
a.reduce( (x,y) => x+y, 0) // => 15; 값의 합계 
a.reduce((x,y) => x*y, 1) // =>120; 값의 곱 
a.reduce((x,y) => (x > y) ? x : y)// =>5; 가장 큰 값
```

reduceRight()는 reduce()와 마찬가지지만

오른쪽에서 왼쪽으로 진행한다는 점이 다름

```jsx
// 2^(3^4)를 계산합니다. 지수는 오른쪽에서 왼쪽으로 연산합니다.
let a= [2, 3, 4];
a.reduceRight((acc,val) => Math.pow(val,acc)) // => 2.4178516392292583e+24
```

### **7.8.2 flat()**과 **flatMap()**을 사용한 배열 평탄화

flat() 메서드는 기존 배열과 같은 요소로 이루어진
‘평탄한 (flat)’ (즉, 중첩되지 않은) 새 배열을 반환

```jsx
[1, [2, 3]].flat() // => [1, 2, 3] 
[1, [2, [3]]].flat() // => [1, 2, [3]]
```

평탄화 레벨을 늘리려면 다음과 같이 flat()에 숫자를 전달

```jsx
let a = [1, [2, [3, [4]]]]; 
a.flat(l) // => [1, , [3, [4]]] 
a.flat(2) // => [1, , 3, [4]] 
a.flat(3) // => [1, , 3, 4] 
a.flat(4) // => [1, , 3, 4]
```

flatMap() 메서드는 map() 메서드와 똑같이 동작하지만,

반환하는 배열이 flat()에 전달한 것처럼 자동으로 평탄화된다는 점이 다름

```jsx
let phrases = ["hello world", "the definitive guide"];
let words = phrases.flatMap(phrase => phrase.split(" ")); 
words // => ["hello", "world", "the", "definitive", "guide"];
```

## **7.8.3 concat()**으로 배열 병합

concat() 메서드는 기존 배열의 요소를 포함하고 

그 뒤에 concat()의 인자를 포함 하는 새 배열을 만들어 반환

```jsx
let a = [1,2,3];
a.concat(4, 5) // => [1,2,3,4,5]
a.concat([4,5], [6,7]) // => [1,2,3,4,5,6,7]; 배열은 평탄화됩니다.
a.concat(4,[5,[6,7]]) // => [1,2,3,4,5, [6,7]; 중첩된 배열은 평탄화되지 않습니다. 
a // => [1,2,3]; 원래 배열은 그대로입니다.
```

## **7.8.4** 스택과 큐 메서드

push()와 pop() 메서드는 배열을 스택처럼 다루는 메서드

push()와 pop()을 조합해 

자바스크립트 배열을 선입 후출의 스택처럼 사용 가능

unshift()와 shift() 메서드는 push(), pop()과 거의 비슷하지만,

배열의 마지막이 아니라 앞부분에서 이루어진다는 것이 다름

## **7.8.5** 하위 배열

### **slice()**

slice() 메서드는 지정된 배열의 하위 배열을 반환
sliceO는 원래 배열을 수정하지 않음

```jsx
let a = [1,2,3,4,5];
a.slice(0,3); //[1,2,3]
a.slice(3); //[4,5]
a.sliced(1,-1); //[2,3,4]
a.slice(-3,-2); // [3]
```

### **splice()**

slice()나 concat()과는 달리 splice()는 원래 배열을 수정

splice()는 제거된 요소로 이루어진 배 열을 반환하며 , 제거 한 것이 없다면 빈 배열을 반환

```jsx
let a = [1,2,3,4,5,6,7,8];
a.splice(4) // => [5,6,7,8]; a는 이제 [1,2,3,4]입니다.
```

### **fill()**

fill() 메서드는 배열의 요소 또는 슬라이스를 지정된 값으로 바꿈

```jsx
let a = newArray(5); // 요소가 없고 길이가5인 배열로 시작합니다.
a.fill(0) // => [0,0,0,0,0]; 배열을 0으로 채웁니다.
a.fill(9, 1) // => [0,9,9,9,9]; 인덱스 1에서 시작해 9로채웁니다.
a.fill(8, 2, -1) // => [0,9,8,8,9]; 인덱스 2에서 시작해 3까지 8로 채웁니다.
```

### **copyWithin()**

copyWithin()은 배열의 슬라이스를 복사해 새 위치에 붙임

```jsx
let a = [1,2,3,4,5];
a.copyWithin(1) // => [1,1,2,3,4]: 전체를 복사해 인덱스 1에 덮어 씁니다. 
a.copyWithin(2, 3, 5) // => [1,1,3,4,4]: 마지막 두 개를 복사해 인덱스 2에 덮어 씁니다. 
a.copyWithin(0, -2) // => [4,4,3,4,4]: 음수도 잘 동작합니다
```

## **7.8.6** 배열 검색과 정렬 메서드

### **indexOf()와 lastlndexOf()**

indexOf()와 lastlndexOf()는 지정된 값을 배열에서 찾아 그 첫 번째 요소의 인덱스를 반환 하며, 찾지 못하면 -1을 반환

indexOf()는 배열의 앞에서부터 검색을 시작하고 lastlndexOf()는 배열의 뒤에서부터 역순으로 검색

```jsx
let a = [0,1,2,1,0]; 
a.indexOf(1) //=>1: a[l]은 1입니다.
a.lastlndexOf(1) // => 3: a[3]은 1입니다.
a.indexOf(3)// => -1: 값이 3인 요소는 없습니다.
```

### **includes()**

인자 하나를 받고 배열에 그 값이 포함되어 있으면 

true를, 그렇지 않다면 false를 반환

```jsx
let a = [1,true,3,NaN]; 
a.includes(true) // => true
a.includes(2) // => false
a.includes(NaN) // => true
a.indexOf(NaN)// => indexOf는 NaN을 찾지 못합니다.
```

### **sort()**

sort()는 배열 요소를 정렬

```jsx
let a = [33, 4, 1111, 222];
a.sort(); // a == [1111, 222, 33, 4]; 알파벳순
a.sort(function(a,b) {// 비교 함수를 전달합니다.
	return a-b; // 순서에 따라 < 0, 0, or > 0인 값을 반환합니다.
}); // a == [4, 33, 222, 1111]; 숫자 순서

a.sort((a,b) => b-a); // a == [1111, 222, 33, 4]; 숫자 순서의 역순
```

### **reverse()**

reverse() 메서드는 배열 요소의 순서를 거꾸로 바꾸어 반환
새 배열을 만들지 않고 기존 배열의 요소 순서를 뒤집음

```jsx
let a = [1,2,3];
a.reverse(); // a == [3,2,1]
```

### **7.8.7** 배열을 문자열로 변환

join() 메서드는 배 열 요소 전체를 문자열로 변환한 다음, 

이들을 병합한 결과를 반환

```jsx
let a= [1, 2, 3]; 
a.join() // => "1,2,3" // => "1 2 3"
a.join(" ") // => "123"
a.join("") // 길이가 10이지만 요소는 없는 배열 let b = new Array(10); 
b.join("-")// => "---------- ": 하이픈 9개
```

join() 메서드는문자열을 분할하는 split() 메서드의 역

### **7.8.8** 정적 배열 함수

Array.of()와 Array.from()은 새 배열을 생성 팩토리 메서드

Array.isArray()는, 값이 배열인지 확인할 때 유용

# **7.9** 배열 비슷한 객체

숫자인 length 프로퍼티가 있고 음이 아닌 정수 프로퍼티가 있는 객체라면,

 모두 일종의 배열로 간주 하더라도 전혀 문제 가 없음

배열 비슷한 객체로 예시

```jsx
let a = {}; // 일반적인 빈 객체로 시작합니다.
// ‘배열 비슷’해지도록 프로퍼티를 추가합니다.
let i = 0; 
while(i < 10) {
	a[i] = i * i;
	i++; 
}

a.length = i;
// 실제 배열인 것처럼 순회합니다.
let total = 0;
for(let j = 0; j < a.length; j++) {
	total += a[j]; 
}
```

# **7.10** 배열인 문자열

자바스크립트 문자열은 UTF-16 유니코드 문자로 구성된 읽기 전용 배열처럼 동작

charAt() 메서드 대신 다음과 같이 대괄호를 써서 개별 문자에 접근

```jsx
let s = "test";
s.ch arAt(0) // => "t" 
s[1] // => "e"
```
