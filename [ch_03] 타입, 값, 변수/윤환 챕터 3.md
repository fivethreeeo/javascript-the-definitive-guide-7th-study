# 3. 타입, 값, 변수

# 3.1 개요와 정의

**JS타입**

1. 기본 타입 : 숫자, 문자열, 불(boolean),null, undefined
2. 객체 타입 :  배열, set, map, RegExp, Date, Error 등

**JS 기본 사항**

- JS의 함수와 클래스는 그 자체가 값이므로 프로그램에서 조작 가능
- JS 인터프리터는 자동으로 가비지 컬렉션을 수행해 메모리를 관리
- JS는 객체（타입 자체）에 그 값을 다루는 메서드를 정의(객체 지향 프로그래밍)
- JS의 문자열은 불변
- 값의 타입을 자유롭게 변형 가능
- 상수(const)와 변수(let)을 통해 값을 참조

# 3.2 숫자

 `Number`: 

자바스크립트의 숫자 타입, 정수와 함께 실수를 대략적으로 표현

직접 기입한 숫자를 숫자 리터럴이라고 부름

## 3.2.1 정수 리터럴

자바스크립트는 10진 정수 리터럴뿐 아니라 16진수 값도 인식

```jsx
0bl0101 // => 21: (1*16 + 0*8 + 1*4 + 0*2 + 1*1) 
00377 // => 255: (3*64 + 7*8 + 7*1)
```

## 3.2.2 부동 소수점 리터럴

부동 소수점 리터 럴에는 소수점이 포함 가능

```jsx
3.14
2345.6789
.333333333333333333
6.02e23 // 6.02 x 1023
1.4738223E-32 // 1.4738223 x 10’32
```

## 3.2.3 자바스크립트의 산술 연산

산술 연산자는  `+` , `-` , `*` ,  `/`, `%` ,`**`

Math 객체의 프로퍼티로 더 복잡한 수학 계산 지원

```jsx
Math.pow(2,53)
// => 9007199254740992: 2의 53승
Math.round(.6)
// => 1.0: 가장 가까운 정수로 반올림
Math.ceil(.6)
// => 1.0: 정수로 올림
Math.floor(.6)
// => 0.0: 정수로 내림
Math.abs(-5)
// => 5: 절댓값
```

JS는 산술 연산 과정에 0으로 나누거나 오버플로, 언더플로가 발생해도 에러 X

오버 플로: 특별한 값 Infinity를 반환

언더 플로: 0을 반환

**0을 0으로 나누는 경우 or 무한대 를 무한대로 나누는 경우** 

or 음수의 제곱근을 구하는 경우 or 숫자로 변 환할 수도 없는 피 연산자에 산술 연산자를 적용 경우 : 

특별한 값 NaN（숫자가 아님）

NaN 값은 자기 자신을 포함해 어 떤 값과도 같지 않음

```jsx
NaN
// 숫자가 아닌 값
Number.NaN
// NaN과 같은 값이며 표현만 다릅니다.
0/0
// => NaN
Infinity/Infinity
// => NaN
```

## 3.2.4 이진 부동 소수점 숫자와 반올림 오류

JS 숫자는 대단히 정밀한 편이며 0.1 을 아주 가깝게 표현하지만, 

가까울 뿐 완전히 정확한 것은 아니기 때문에 문제가 생길 수 있음

```jsx
let x = .3 - .2; // 0.3 빼기 0.2
let y = .2 - .1; // 0.2 빼기 0.1
x === y // => false: 두 값은 같지 않습니다!
x === .1// => false: 0.3 - 0.2는 0.1 과 같지 않습니다.
y === .1// => true: 0.2 - 0.1 은 0.1 입니다.
```

부동 소수점 근삿값 때문에 프로그램에 문제가 생긴다면 정수로 변환하는 것을 고려

## 3.2.5 Biglnt로 임의 정확도를 부여한 정수

`Biglnt`

ES2020에서 정의한 자바스크립트의 최신 기능,

다른 프로그래밍 언어나 API와의 호환에 필요한 64비트 정수를 표현하기 위해 추가

Biglnt 리터 럴은 연속된 숫자 다음에 소문자 n을 붙인 형식

나눗셈을 할 때 나머지를 버림

## 3.2.6 날짜와 시간

`Date`

날짜와 시간에 대응하는 숫자를 표현하고 조작하는 객체

# 3.3 텍스트

문자열

자바스크립트에서 텍스트를 표현하는 타입

문자열은 16비트 값 이 순서에 따라 이어진 형태이며, 기본 값이므로 불변

## 3.3.1 문자열 리터럴

문자열을 사용 시 (`‘`), (`“`),(`'`) 쌍으로 묶으면 됌

**보간(interpolation)**

`'` 백틱으로 감싼 문자열은 ES6 기능이며,

문자열 리터럴 안에 자바스크립트 표현식을 넣을 수 있음

## 3.3.2 문자열 리터럴 안의 이스케이프 시퀀스

`\`역슬래시

그 다음 문자와 조합해서 일반적인 방법으로는 문자열에 표시할 수 없는 문자를 표현

```jsx
'You\‘re right, it can\'t be a quote'
//You‘re right, it can't be a quote
```

## 3.3.3 문자열 다루기

JS는 문자열을 ‘병합(연결)’하는 기능이 내장

`+` 연산자를 문자열에 쓰면 두 번째 문자열을 첫 번째 문자열 뒤에 이음

문자열의 길이

그 안에 포함된 16비트 값의 개수는 `length` 프로퍼티 사용

다양한 문자열 API

```jsx
s.sliced,4 // => HellH: 같은 결과입니다.
s.slice(-3) // => HridH: 마지막 세 문자
s.split(", ") // => [HHelloh, HworldU] 구분자를 기준으로 나눕니다.
```

**자바스크립트의 문자열은 불변**

replace()나 toUpper CaseO 같은 메서드는 

기존 문자열을 수정하는 것이 아니라 새 문자열을 반환

## 3.3.4 템플릿 리터럴

ES6부터는 백틱으로 감싼 문자열 리터럴을 사용가능

템플릿 리터럴 안에 쓸 수 있는 표현식 개수에는 제한 X

```jsx
let name = "Bill";
let greeting = 'Hello ${ name // greeting == "Hello Bill."
```

**태그된 템플릿 리터럴**

백틱 바로 앞에 함수 이름(태그)이 있으면 템플릿 리터 럴의 텍스트와 표현식 값이 함수 에 전달

```jsx
'\n'.length // => 1: 이 문자열에는 뉴라인 문자 하나만 있습니다.
St ring. raw' \n'. length // => 2: 역슬래시 문자와 n
```

## 3.3.5 패턴 매칭

`정규 표현식(RegExp)` 

문자열 내부의 패턴을 정의하고 매칭하는 이라는 데이터 타입

슬래시 한 쌍 사이에 텍스트를 쓰는 형태, 텍스트 처리에 자주 사용

# 3.4 불 값

`boolean`

참 또는 거짓을 표현

이 타입에는 단 두 가지 값만 존재 ( true와 false)

# 3.5 null과 undefined

`null`

값이 없음을 나타낼 때 사용하는 특별한 값

typeof 연산자를 사용하면 문자열 “object”를 반환

프로그램 레벨이고 정상적이거나 예측된 상황에서 값이 없는 것(의도)

`undefined`

값은 초기화되지 않은 변수의 값

존재하지 않는 객체 프로퍼티나 배열 요소에 접근했을 때 반환되는 값

typeof 연산자를 적용하면 문자열 “undefined”를 반환

시스템 레벨이고 예측되지 않았거나 에러 비슷한 상황 에서 값이 없는 것(의도X)

# 3.6 심벌

`symbol`

문자열이 아닌 프로퍼티 이름으로 ES6에서 추가

심벌 타입에는 리터럴 문법이 X

Symbol은 절대 같은 값을 반환 X , Symbol.for()는 같은 문자열로 호출했을 때 항상 같은 값을 반환

```jsx
let s = Symbol.for("shared");
let t = Symbol.for("shared");
s === t // => true
s.toString() // => "Symbol(shared)" 
Symbol.keyFor(t) // => "shared"
```

# 3.7 전역 객체

*전역 객체의 프로퍼티는 전역으로 정의된 식별자, 모든 JS 프로그램에서 사용*

Window 객체에는 자신을 참조하는 window 프로퍼티 존재. 이 프로퍼티를 통해 전역 객체를 참조

노드의 전역 객체에는 이름이 global인 프로퍼티 존재, 그 값은 전역 객체 자체

ES2020에서 정의한 **globalThis**는 어떤 환경에서든 전역 객체를 참조하는 표준

# 3.8 불변인 기본 값과 가변인 객체 참조

JS에서는 기본값(undefined, null, 불, 숫자, 문자열)은 불변 / 객체,배열은 가변

문자열 예시

```jsx
let s = HhelloH; // 소문자 텍스트로 시작합니다. 
s.toUpperCaseO; // HELLO를 반환하지만 s는 그대로입니다.
s // => "hello": 원래 문자열은 변하지 않았습니다.
```

**객체의 프로퍼티와 값이 같다고 해서 같은 객체는 아님**

```jsx
let o = {x: 1}, p = {x: 1}; // 프로퍼티가 같은 두 객체 
o === p    // => false: 별개의 객체가 일치할 수는 없습니다.
let a = [], b = [];   // 별개인 두 빈 배열
a === b  // => false: 별개의 배열이 일치할 수는 없습니다.
```

객체나 배열을 변수에 할당한다고 해서 객체의 사본이 새로 생기는 것은 아님

객체나 배열의 사본을 만들기 위해서는 반드시 객체 프로퍼티나 배열 요소 를 직접 복사

```jsx
let a = ["a","b","c"]; // 복사할 배열
let b = []; // 복사해 넣을 대상
for(let i = 0; i < a.length; i++) { // a의 각 인덱스에 대해
b[i] = a[i]; // a의 요소를 b에 복사합니다.
}
let c = Array, from(b); // ES6에서는 Array.from()으로 배열을 복사
```

# 3.9 타입 변환

JS는 값의 타입을 강제하지 않음

```jsx
10 + " objects" // => "10 objects": 숫자 10이 문자열로 변환됩니다.
```

## 3.9.1 변환과 일치

일치 연산 자 `===`는 두 피 연산자가 다른 타입 이면 같지 않다고 판단하며, 

동등 연산자 `==`를 선택하는 것보다 거의 항상 더 좋음

## 3.9.2 명시적 변환

명시적으로 타입을 변환하는 가장 단순한 방법은 Boolean(), Number(), String ()

묵시적 타입 변환

```jsx
x + "" // => String(x)
+x // => Number(x)
x-0 // => Number(x)
! !x // => Boolean(x): !가 두 개입니다.
```

## 3.9.3 객체를 기본 값으로 변환

### toString() 과 valueOf() 메서드

toString()은 객체의 문자열 표현을 반환

```jsx
[1,2,3].toString() // => "1,2,3"
(function(x) { f(x); }).toString() // => //function(x) { f(x); }"
```

valueOf()은 객체를 표현하는 기본 값이 존재한다면 그 값으로 객체를 변환

기본 valueOf() 메서드는 기본 값이 아니라 객체 자체를 반환

```jsx
let d = new Date(2010, 0, 1); // 2010년 1 월 1일
d.valueOfO // => 1262271600000
```

# 3.10 변수 선언과 할당

변수:

새로운 값을 할당할 수 있음을 암시

상수:

값에 이름을 영구히 할당할 때

ES6 이후에는 let과 const 키워드를 사용해 변수를 선언

## 3.10.1 let과 const를 사용한 선언

let을 선언할 때 초깃값을 할당하는 것이 좋은 프로그래밍 습관

let 문에서 변수에 초깃값을 할당하지 않으면 값을 할당할 때까지 undefined

```jsx
let message = "hello";
```

상수를 선언할 때는 const를 사용, const는 let과 거의 비슷하지만, 선언 할 때 반드시 값을 할당

상수를 선언할 때는 H0나 HTTP_N0T_F0UND처럼 전부 대문자를 써서 변수와 구별

상수의 값을 바꾸려 하면 TypeError

```jsx
const H0 = 74; // 허블 상수 (km/s/Mpc)
```

**변수와 상수 스코프**

**변수의 스코프(scope)**

프로그램 소스 코드에서 해당 변수가 정의된 영역

let과 const로 선언한 변수와 상수는 블록 스코프를 가짐

(=let이나 const 문이 존재하는 블록 안에서만 해당 변수와 상수가 유효)

선언이 어떤 코드 블록에도 속하지 않고 최상위 레벨에 있을 경우,

이를 전역 변수 또는 상수라고 부르며, 이들은 전역 스코프를 가짐

**반복 선언**

```jsx
const x = 1; // x를 전역 상수로 선언합니다.
if （x === 1） {
let x = 2; // 블록 안에서 다시 선언할 수 있습니다.
console.log（x）; // 2
}
console.log（x）; // 1: 지금은 전역 스코프에 있습니다.
let x = 3; // 에러. x를 다시 선언하려 하는 것은 문법 에러입니다.
```

## 3.10.2 var를 사용한 변수 선언

var의 문법은 let과 동일

var로 선언한 변수는 블록 스코프를 갖지 X

호이스팅（끌어올림) 기능

`var`를 초기화하기 전에 사용한다고 해서 에러가 발생하지는 않습니다. 

**이런 특징은 버그 의 원인이 될 수 있으며, ES6 이후에 let으로 수정한 중요한 결점 중 하나**

## 3.10.3 분해 할당

분해 할당 （destructuring assignment)

ES6에서는 선언과 할당을 합친 일종의 복합 문법을 도입

오른쪽 값에서 하나 이상의 값을 추출（분해）해서 왼쪽에 있는 변수에 할당

중첩된 객체, 객체의 배열, 배열의 객체 등에도 사용 가능

```jsx
let [x,y] = [1,2]; // let x=l, y=2와 같습니다.
[x,y] = [x+l,y+l]; // x = x + 1, y = y + 1과 같습니다.
[x,y] = [y,x]; // 두 변수의 값을 바꿉니다.
[x,y] // => [3,2]: 값을 증가시킨 후 서로 바꿨습니다.
```

복잡한 분해 할당의 이해

```jsx
// 분해 할당으로 시작합니다.
let points = [{x: 1, y: 2}, {x: 3, y: 4}];
let [{x: xl, y: yl}, {x: x2, y: y2}] = points;
// 할당을 뒤집어 문법을 체크할 수 있습니다.
let points? = [{x: xl, y: yl}, {x: x2, y: y2}];
points2 // => [{x: 1, y: 2}, {x: 3, y: 4}]
```