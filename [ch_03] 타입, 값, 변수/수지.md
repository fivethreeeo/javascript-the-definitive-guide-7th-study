# 3-1. 타입, 값, 변수 개요와 정의

## 타입(data type)에 대해 각각 살펴 볼 수 있다. (3-2 ~ 3-7)

자바스크립트의 타입은 기본 타입과 객체 타입으로 나뉘며, 총 7개의 타입을 제공한다.

- 기본 타입(원시타입 primitive type) : 숫자(Number), 문자(String), 불(Boolean), null, undefined, 심벌(Symbol)
- 객체 타입(Object/reference type) : 기본 타입에 속하지 않는 모든 값들 (객체, 배열, 함수, 클래스, Set, Map, RegExp, Date, Error ...)

### 🔗 참고 - 자바스트립트 인터프리터

- 자바스크립트 인터프리터는 자동으로 **가비지 컬렉션을 수행**해 메모리를 관리한다.
- 프로그램에서 어떤 값이 더이상 참조하지 않게 되면, 인터프리터는 그 값을 인식하고 그 값이 차지하고 있던 메모리를 자동으로 다시 확보해가기 때문에 개발자가 객체나 다른 값을 직접 파괴하거나 할당을 해제할 필요가 없다.

## 📌 자바스크립트의 전역 객체(3-7)에 대해 살펴볼 수 있다.

자바스크립트는 객체 지향 프로그래밍 스타일을 지원한다.

- 객체에 그 값을 다루는 메서드를 정의함.
- 오직 객체만 메서드를 가질 수 있음.
- 하지만, null과 undefined를 제외한 기본타입에서도 마치 메서드가 있는 것처럼 동작함.

## 📌 mutable과 immuatable의 차이점(3-8)에 대해 살펴볼 수 있다.

- 가변(mutable) : 객체 타입의 속성, 값이 바뀔 수 있다.
- 불변(immuatable) : 기본 타입의 속성, 값이 바뀌지 않는다.

## 📌 타입 변환의 규칙(3-9)과 변수 선언과 할당(3-10)에 대해 살펴볼 수 있다.

- 자바스크립트는 값의 타입을 자유롭게 변환하지만, 값 변환에는 규칙이 존재한다.
- 자바스크립트에서는 상수와 변수의 이름을 통해 값을 참조한다.

# 3-2. 숫자타입(Number)

- 64비트 부동 소수점 형식 : 소수점 사용이 가능하며, 하나의 값을 최대 64비트에 유사한 근삿값으로 담음.
- 리터럴 : 사람이 알아볼 수 있는 문자나 기호를 사용해 값을 생성하는 표기법.

자바스크립트 Number타입은 정수와 함께 실수를 대략적으로 표현한다.
자바스크립트는 64비트 부동 소수점 형식을 사용하며, 다양한 숫자 리터럴 형식을 지원한다.

## 📌 정수 리터럴

자바스크립트에서는 10진 정수 뿐만 아니라 다양한 진수를 인식할 수 있다.

- 10진 정수: 연속된 숫자로 표현함.
- 16진수: 0x 또는 0X 뒤에 16진수 숫자를 사용함.(0~9 숫자나 a(A)~f(F) 문자이며, 10부터 15까지 나타냄)
- 2진수: 0b(0B) 뒤에 2진수를 사용함(0과 1로 이루어진 숫자)
- 8진수: 0o(0O) 뒤에 8진수를 사용함

## 📌 부동 소수점 리터럴

소수점이 포함 될 수 있으며, 실수의 전통적 문법을 사용한다. (값 = 정수부분 + 소수점 + 소수점 아래부분)

- 지수 표기법: 숫자.소수점아래부분e(E)(+||-)지수를 나타내는 정수

### 🔗 참고 - 숫자 리터럴의 구분자

- 숫자 리터럴 안에 구분자(언더바, 밑줄)을 사용해서 리터럴을 읽기 쉽게 나눠 쓸 수 있다.

```
let num = 1_000_000; // 1000000
num === 1000000 //true
```

## 📌 자바스크립트의 산술 연산

자바스크립트에서는 산술 연산자를 통해 숫자를 조작한다.

- 덧셈(+), 뺄셈(-), 나눗셈(/), 곱셈(\*), 나머지(%), 지수(\*\*)

기본 산술 연산자 외에도 Math 객체의 메서드를 통해 복잡한 수학계산을 지원해준다.

자바스크립트에서는 0으로 나누거나, 오버플로(가장 큰 숫자보다 큰 경우), 언더플로(가장 작은 숫자보다 작은 경우)가 발생해도 에러가 일어나지 않는다.

- Infinity , -Infinity : 양의 무한대, 음의 무한대
- NaN : 계산할 수 없음, 숫자가 아닌 값, 전역함수 `isNaN()`과 `Number.isNaN()`이 있음.

## 📌 이진 부동 수소점 숫자와 반올림 오류

자바스크립트에서 실수를 다룰 때, 범위 이상의 값은 근삿값으로 반올림하므로 오류가 종종 발생한다.

```
let sum1 = 0.1 + 0.2; // 0.30000000000000004
let sum2 = 0.3;
sum1 === sum2 // false
```

오류를 해결하기 위해선 정수로 변환하는 방법을 고려하거나, 두 실수의 오차범위를 설정해서 그 범위보다 차이값이 작다면 같은 값이라고 정의하는 방법이 있다.

## 📌 BigInt로 임의 정확도를 부여한 정수

BigInt는 값이 정수인 숫자 타입이며, 다른 프로그래밍 언어나 API와의 호환에 필요한 64비트 정수를 표현하기 위해 추가되었다.

- BigInt 리터럴 : 연속된 숫자에 소문자 n을 붙인 형태

## 📌 날짜와 시간(Date)

Date 클래스는 날짜와 시간에 대응하는 숫자를 표현하고 조작한다.
Date는 객체이지만 timestamp인 숫자 표현(현재 시간을 숫자형식으로 표현)을 가지고 있다.

# 3-3. 텍스트(String)

자바스크립트에서 텍스트를 표현하는 타입은 문자열이다.
16비트 값이 순서에 따라 이어진 형태이며, 각 값은 일반적으로 유니코드 문자이고 기본 값이므로
불변(immutable)인 특징을 가지고 있다.

- length : 문자열의 길이
- index : 값의 위치, 0부터 시작함

## 📌 문자열 리터럴

문자열은 앞 뒤가 맞는 작은따옴표(''),큰따옴표(""),벡틱(``)을 사용한다.

- `+` 연산자 : 문자열을 합칠 수 있다.
- `\` 역슬래쉬: 문자열 끝에 붙이면 행을 구분 지을 수 있다.

## 📌 문자열 리터럴 안의 이스케이프 시퀀스

`\`(역슬래쉬)는 뒷 문자와 조합을 이뤄서 문자열에 표시할 수 없는 문자를 표현한다.

- 이스케이프 시퀀스 : 역슬래쉬를 써서 작은 따옴표로 감싸인 문자의 일반적인 해석 방법을 벗어난다는 의미를 나타냄.

## 📌 문자열 다루기

자바스크립트 문자열에는 병합(연결) 기능이 내장되어 있다.
문자열에 `+`연산자를 숫자나 문자와 함께 사용하면 첫번째 문자열에 뒤 이어 붙인다.
숫자 타입과 마찬가지로 문자열에서 사용할 수 있는 다양한 내장 메서드들이 존재한다.

## 📌 템플릿 리터럴

- 템플릿 리터럴 : 일반적인 문자열 리터럴 문법과는 다르게 임의의 자바스크립트 표현식을 넣을 수 있다. 벡틱(``)안에 '${}'를 사용하여 표현식을 평가하고, 문자열로 변환한다.

## 📌 패턴 매칭(정규 표현식 RegExp)

자바스크립트의 기본적인 데이터 타입은 아니지만, 리터럴 문법이 존재하여 데이터 타입처럼 보인다.
`//` 슬래쉬 사이에 텍스트를 쓰는 형태이며 닫는 슬래쉬 뒤에도 글자를 쓸 수 있다.

# 3-4. 불 값(Boolean)

불 값은 true(참) 또는 false(거짓)을 표현한다.
일반적으로 비교 결과를 나타내며, 자바스크립트에서 일반적으로 true와 false값을
반환하는 truthy와 falsy가 존재한다.

## 📌 falsy 값들

자바스크립트에선 아래와 같은 6가지 값들은 항상 false를 반환하는 falsy 값들이다.

- `undefined`
- `null`
- `0`
- `-0`
- `NaN`
- `""` : 빈문자열

## 📌 불 연산자

- `&&`: (and) 두 피연산자 모두 true여야 true로 평가된다.
- `||`: (or) 두 피연산자 중 하나라도 true 값이라면, true로 평가된다.
- `!`: (not) true와 false 값을 반전시킨다.

# 3-5. null 과 undefined

null 과 undefined는 둘 다 값이 없음을 나타낼 때 사용하는 특별한 값이다.

- `null` : 주로 임의적으로 빈 값을 할당해야 할 때 null을 사용한다. null에 typeof를 사용하면 'object'가 나오는데 이는, 비어있는 객체라는 의미로 특별한 객체 값이라고 볼 수 있다. 하지만 typeof null과 {}는 엄연히 다른 값이다.
  정리하자면 그 변수는 더 이상 참조되지 않겠다는 의미이며 가비지 콜렉션 수행과도 연결이 된다.
  프로그래머가 함수를 작성할때 함수가 반환할 값이 없는경우 명시적으로 null을 반환하도록 작성하는 경우도 있음

```
typeof null //'object'
typeof null === 'object' //true
typeof null === {} //false
```

- `undefined`: 미리 정의된 전역 상수이며, 값은 undefined로 초기화가 된다. null과는 다르게 typeof 를 사용하면 'undefined'를 반환한다.

# 3-6. 심벌(Symbol)

## 📌 Symbol 사용

심벌은 객체 프로퍼티의 이름으로 사용하기 위해 추가되었다.
`Symbol()`를 호출하여 괄호안 값의 접근성을 제어할 수 있다.
주로 고정된 상수 또는 constant에 사용된다.

# 3-8. 불변인 기본 값과 가변인 객체 참조

객체 타입과 원시 타입의 차이점은 각각 mutable과 immuatable의 특징을 가지고 있다는 점이다.

- 가변(mutable) : 객체 타입의 속성, 값이 바뀔 수 있다.
- 불변(immuatable) : 기본 타입의 속성, 값이 바뀌지 않는다.

## 📌 값에 의한 전달과 참조에 의한 전달

- 값에 의한 전달(call by value)

```
// 값에의한 전달!
let x = 10;

// x -> n으로 전달 되면서 x의 값 자체가 복사 일어남
const add3 = function (n) {
  n = n + 3;

  return n;
}

const result = add3(x);

console.log(result); // 13
console.log(x); // 10 <---- 콜바이벨류 !
```

- 참조에 의한 전달(call by reference)

```
let hansuzi = {
    name: 'hansuzi',
    friends: ['a', 'b', 'c']
};

// 위험하게 얕은 복사해서 조작하는 함수 -> 원래 객체의 상태를 변경 할수있으니까!
const addFriendD = function (obj) {
    // 객체를 복사하면 해결 - 근데 얕은 복사
    const clone = {
        name: obj.name,
        friends: obj.friends // 주소값이기 때문에 원래 주소에 있는 정보까지 변경 여지가 있음/
    }

    clone.friends.push('d');

    return clone.friends;
}

// 원본 객체
hansuzi = {
    name: 'hansuzi',
    friends: ['a', 'b', 'c']
};

// 앝은 복사 된 객체는 이렇게 생겻음
clone = {
    name: 'hansuzi',
    friends: hansuzi.friends
};


// 깊은 복사 된 객체는 이렇게 생겻음
clone = {
    name: 'hansuzi',
    friends: hansuzi.friends를 토대로 만든 새로운 배열 ['a', 'b', 'c']
};


// 안전하게 깊은 복사해서 조작하는 함수
const addFriendDeep = function (obj) {
    // 객체를 복사하면 해결 - 근데 얕은 복사
    const clone = {
      name: obj.name,
      friends: new Array(...hansuzi.friends)
    }

    clone.friends.push('d');

    return clone.friends;
}


// const result = addAge(hansuzi);
const result1 = addFriendDeep(hansuzi);


console.log(result1); //
console.log(hansuzi.friends); //

// 주의
```

# 3-9. 타입 변환

자바스크립트에서는 암묵적 타입변환와 명시적 타입변환이 있다.

- 암묵적 타입변환: 자바스크립트가 암묵적(묵시적)으로 타입을 변환하는 과정
- 명시적 타입변환: 프로그램에서 개발자가 직접 타입을 변환하는 방법

## 📌 타입 캐스팅과 타입 강제변환

개발자의 의도와 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 바뀌는걸 암묵적타입변환, 엔진에 의한 타입 강제변환이라고한다.

개발자가 의도적으로 값의 타입을 바꾸는 작업을 타입캐스팅, 명시적타입변환이라고 한다.

- 암묵적 타입 변환이 일어나는 경우

  - 산술연산자에 의한 타입변환
  - 조건식에의해 불리언 타입으로 변환되는 경우

- 산술연산자에 의한 타입변환이 일어나는 경우
  - `+` : 단항으로 쓰일경우 number우선, 2항연산자로 쓰일경우 문자열 우선
  - `- * /` : 전부 number우선

# 3-10. 변수 선언과 할당

변수는 특정 값이 저장된 메모리의 위치를 포함하고 있으며, 변수 이름을 통해 재사용이 가능하다.
자바스크립트에서 변수를 선언하는 키워드에는 `var, let, const`가 있다.
값을 선언하는 단계와 할당하는 단계가 다르게 존재한다.

- 동적 타입추론(동적 타이핑): 자바스크립트는 변수 선언시점이 아닌 변수에 값을 할당하는 시점에 그 변수의 타입이 결정된다. 그리고 정해진 변수의 타입은 언제든 자유롭게 변경이 가능하다.

## 📌 변수를 사용하는 이유와 정의

애플리케이션은 데이터를 다룬다.
아무리 복잡한 애플리케이션이라 해도 데이터를 입력(input)받아 처리하고,
그 결과를 출력(output)하는 것이 전부다.
변수는 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념이다.
변수란 무엇인지 그리고 왜 필요한지 살펴보자.

컴퓨터는 사람을 모델로 디자인되었기 때문에 사람과 유사하게 동작한다.
자바스크립트 엔진도 사람과 유사하게 위 자바스크립트 코드를 실행한다.
자바스크립트 엔진이 위 자바스크립트 코드를 계산(평가 evaluation)하려면
먼저 기호(리터럴 literal과 연산자 operator)의 의미를 알고 있어야 하며,
표현식(expression)의 의미도 해석(파싱 parsing)할 수 있어야 한다.

자바스크립트 엔진은 하나의 식의 의미를 해석하기 위해 먼저 피연산자(operand)를 기억한다.
컴퓨터는 CPU를 사용해 연산하고, 메모리(memory)를 사용해 데이터를 기억한다.

- 메모리는 데이터를 저장할 수 있는 메모리 셀(하나당 1바이트 = 8비트)의 집합체이다.
- 컴퓨터는 메모리 셀 1바이트 단위로 저장(write)하거나 읽어(read)들인다.
- 각 셀은 메모리 공간의 위치를 나타내는 고유의 메모리 주소(address)를 갖는다.
- 컴퓨터는 모든 데이터(숫자, 텍스트, 이미지, 동영상 ...)를 2진수로 처리한다.

이렇게 저장된 데이터를 다시 재사용하기 위해서는 메모리 주소에 접근을 하여야 하는데,
메모리 주소를 통해 값에 직접 접근하는 것은 치명적인 오류를 발생시킬 가능성이 매우 높은 위험한 일이다.

- why?
  값이 저장될 메모리 주소는 코드가 실행될 때 임의로 결정이 되며, 실행될 때마다 값이
  저장될 메모리 주소는 변경된다. 또한, 코드가 실행되기 이전에는 값이 저장된 메모리 주소를 알 방법이 없다.
  만약 실수로 운영체제가 사용하고 있는 값을 변경하면 시스템을 멈추게하는 치명적인 오류가 발생할 수 있기 때문에 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.

그렇기에 개발자가 안전하게 값에 접근하도록, 프로그래밍 언어에서는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 그 값을 재사용하기 위해 '변수'를 사용한다.

변수(variable)는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.

간단히 말하자면 변수는 프로그래밍 언어에서 값을 저장하고 참조하는 메커니즘으로,
값의 위치를 가리키는 상징적인 이름이다.

```
//키워드 식별자
var input;
//키워드 식별자 할당연산자 값
var result = 10;
```

이렇게 작성된 변수는 프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행된다.

```
var result = 10 + 20;
```

위 코드에서 하나의 변수에 몇 가지의 값이 저장되는지 생각해보자.
컴퓨터는 코드를 실행 시키기 위해, 먼저 키워드를 통해 선언된 변수에 접근을 하여
10과 20이라는 값을 각각 메모리 주소에 저장을 한다.
그 뒤, `+` 연산자를 읽어들여 10과 20을 더한 30이라는 새로운 값을 생성하여 메모리 주소에 저장한다.
10, 20, 30은 모두 서로 다른 메모리 주소를 가지고 있지만, 변수 result는 연산의 결과로 생성된 새로운 값 30에 해당하는 메모리 주소만을 가리키는 식별자가 된다.
즉, 변수는 하나의 값을 저장하기 위한 수단이다.

식별자는 메모리 공간에 저장된 값을 식별할 수 있는 고유의 이름(변수명)이며,
변수에 저장된 값을 변수 값이라고 한다.

변수에 값을 저장하는 것을 할당(대입, 저장)이라고 하고, 메모리 주소를 통해 저장된 값을 읽는 과정 즉, 변수에 저장된 값을 읽어 들이는 것을 참조(reference)라고 한다.

식별자를 통해 참조를 요청할 수 있으며, 자바스크립트 엔진은 식별자와 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환한다.

그렇기에, 식별자(변수명)는 변수에 저장된 값의 의미를 명확히 해야 할 필요성이 있다.
변수명을 지을 때 저장된 값의 의미를 파악할 수 있도록 심사숙고해서 작성한다면, 코드의 가독성을 높이고 협업과 품질 향상에 많은 도움을 주게 될 것 이다.

항상 좋은 이름을 짓는 습관을 기르도록 노력하자.

그렇다면, 하나의 변수에 여러 가지 값을 담는 방법은 없는 걸까?
아래 코드에서 사용된 user나 users처럼 객체나 배열과 같은 자료구조를 사용하면 여러 개의 값을
하나로 그룹화해서 하나의 값처럼 사용할 수 있게 된다.

```
//하나의 변수에 여러 값을 저장하는 방법 예시
var userId = 1;
var userName = 'Han';
var user = { id: 1, name: 'Han' };
var users = [
  {id: 1, name: 'Han'},
  {id: 2, name: 'Lee'}
]
```

userId와 userName은 각각 1과 'Han'이라는 하나의 값을 담고 있는 변수이지만,
user는 객체의 특성상 1과 'Han'이라는 값(value)과 그 값들을 담고 있는 키(keys) id와 name을 담고 있다.
users에는 총 4가지의 값과 4가지의 키를 저장하고 있으며, 배열의 특성상 2개의 index를 가지고 있다.

## 📌 식별자(변수 명/ 변수이름)에 대한 추가적인 설명

```
var identifier;
var isIdentifier = '메모리 주소를 기억해 값을 식별';
```

변수를 생성할 때 컴퓨터가 하나의 메모리 공간을 확보하여 값을 추가하고,
그 공간에 각각의 메모리 주소를 부여한다는 사실을 알게 되었다.

이때, 사용되는 변수 이름을 식별자(identifier)라고도 한다.
식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 의미 한다.
식별자는 어떤 값이 저장되어 있는 메모리 주소를 기억(저장)해야 한다.

여기서 유의해야 할 점은,
값은 메모리 공간에 저장되어 있으며, 식별자는 값이 아니라 그 값이 저장된 메모리 공간의 주소를 기억하고 있다는 점이다.

즉, 식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보도 메모리에 저장되어야 한다.

식별자로 값을 구별해서 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 의미이다.

그렇기에, 자바스크립트에서의 식별자라는 용어는 변수 이름에만 국한해서 사용하지 않는다.
(ex. 변수, 함수, 배열, 객체, 클래스 등의 이름은 모두 식별자이다.)

즉, 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 부른다.

식별자는 네이밍 규칙(컨벤션)을 준수해야 하며,
선언(declaration)에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.

## 📌 변수 선언에 대한 추가적인 설명

변수 선언(declaration)이란 변수를 생성하는 것을 말한다.
좀 더 자세히 말하면 값을 저장하기 위한 메모리 공간을 확보(allocate)하고 변수 이름과 확보된 메모리 공간의 주소를 연결(name binding)해서 값을 저장할 수 있게 준비하는 것이다.
변수 선언에 의해 확보된 메모리 공간은 확보가 해제(release)되기 전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전하게 사용할 수 있다.

```
var javascript;
let variable;
const declaration;
```

변수를 사용하려면 반드시 선언이 필요하다.
위 코드와 같이 변수를 선언할 때는 식별자 앞에 var, let, const 키워드를 사용한다.

선언을 하는데 왜 굳이 3가지의 키워드나 필요한 것일까?
이를 이해하려면 먼저 var 키워드가 가진 단점에 대해 알아 둘 필요가 있다.

ES5까지 var 키워드는 자바스크립트에서 변수를 선언할 수 있는 유일한 키워드였다.
하지만 var 키워드가 여러가지 단점을 가지고 있었기에, ES6에서 선언을 할 때 let, const 키워드가 추가된 것 이다.
var 키워드의 사용을 지양해야 하는 대표적인 이유 중 하나는 바로 블록 레벨 스코프를 지원하지 않고, 함수 레벨 스코프를 지원한다는 것이다.
이로 인해 의도치 않게 전역 변수가 선언되어 심각한 부작용이 발생할 가능성이 있다.

위 내용들은 추후 배우게 될 스코프, 전역 변수의 문제점, 실행 컨텍스트와 자세히 연결되는 중요한 개념들이다.

```
var score; //undefined
```

변수 선언을 하게 되면, 자바스크립트 엔진에서 무슨 일이 일어날까?

자바스크립트 엔진은 위 코드처럼 키워드가 선언되면 가장 먼저, 식별자를 실행 컨텍스트에 등록하고 값을 저장할 메모리 공간을 확보한다.(실행 컨텍스트 내에 키와 값 형식인 객체로 등록하여 관리함)
위처럼, 변수 score에 값을 아직 할당하지 않은 상태라 해도 자바스크립트 엔진은 undefined라는 값을 메모리 공간에 암묵적으로 할당해서 초기화 시키는 독특한 특징을 가지고 있다.
다른 언어(C, C++ ...)에서는 변수를 쓰기전에 먼저 초기화를 시키지 않으면 다른 애플리케이션에 사용했던 쓰레기 값(garbage value)가 담겨있지만, 자바스크립트는 자체적으로 변수가 선언될 때 메모리 공간에 undefined로 초기화하는 작업을 가장 먼저 실행한다.

즉, 변수 선언시 선언 단계와 초기화 단계가 각각 실행되는 것이다.

var 키워드는 let과 const와는 다르게 변수 선언시에 선언 단계와 초기화 단계가 동시에 진행된다.
일반적으로 초기화(initialization)란 변수가 선언된 이후 최초로 값을 할당하는 것을 말한다.
변수(모든 식별자)를 사용하려면 반드시 선언이 필요하다.

만약, 변수를 선언하기 전에 실행이 먼저 진행된다면 무슨 일이 일어날까?

```
console.log(a);
var a;

console.log(b);
let b;

console.log(c);
const c;
```

일반적으로 변수를 선언 하기 전에 런타임이 일어나게 된다면,
자바스크립트 엔진은 식별자를 통해 값에 접근하려 했지만 등록된 식별자를 찾을 수 없기 때문에 ReferenceError(참조 에러)를 발생시킨다. 하지만 var 키워드만 undefined로 초기화가 된 것을 확인할 수 있다.

이는, 자바스크립트의 특징 중 하나인 호이스팅(hoisting)의 현상이다.

## 📌 var, let, const의 차이점

- `var`: 함수 레벨 스코프를 지원하기 때문에 다양한 문제점을 발생시킨다. 호이스팅 될 시에 선언과 초기화 단계가 동시에 일어나며, var 키워드로 선언시에 중복 선언을 허용한다는 문제점을 가지고 있다.
- `let`: 블록 레벨 스코프를 지원하며, 재할당이 가능하다. 선언과 초기화의 시점이 다르기 때문에 그 사이에 일시적 사각지대(TDZ)가 존재하며, 중복 선언시에 오류 발생이 된다.
- `const`: `let`과 비슷한 특징을 가지고 있지만, const는 재할당을 금지시키기 때문에 주로 상수에 많이 사용된다.

### 🤔 추가적으로 생각해 볼 질문들

- [x] 변수 호이스팅이란?
- [x] var 키워드와 let 키워드의 차이점
- [x] let 키워드와 const 키워드의 차이
- [x] 자바스크립트에서 예약어란?
- [x] 매니지드 언어와 언매니지드 언어의 차이
- [x] 자바스크립트의 기본적인 네이밍 컨벤션
- [x] 값과 리터럴의 차이점
- [x] 자바스크립트의 타입들에 대한 설명(원시타입과 객체타입 분리)
- [x] 자바스크립트 숫자타입은 전부 어떤 형식으로 작동하고 그러므로 어떤걸 주의 해야 할까?
- [x] 탬플릿리터럴 문법에 대한 설명
- [x] 이스케이프 시퀀스란?
- [x] null과 undefined의 차이
- [x] 자바스크립트에서의 동적 타이핑(동적 타입 추론)이란?
- [x] 명시적 타입변환, 암묵적 타입변환, 타입캐스팅, 타입강제변환에 대한 설명
- [x] 암묵적 타입 변환과 명시적 타입 변환이 일어나는 경우는?
- [x] 조건식에서 False로 평가되는 값들은?
- [x] 값에의한 전달과 참조에 의한 전달에 대해 설명
- [x] 이뮤터블 과 뮤터블의 특성이란?
- [x] 호이스팅과 스코프의 관계성이란?
- [x] var 키워드가 let이나 const 키워드와 스코프, 호이스팅 측면에서 다른점은?
- [x] 전역변수와 지역변수의 차이점
- [x] 지역변수의 생명주기란?
- [x] var로 선언한 전역변수와 let으로 선언한 전역변수의 차이점
- [x] var, let, const 키워드들을 어떤 상황에 맞게 사용하면 좋을까?
