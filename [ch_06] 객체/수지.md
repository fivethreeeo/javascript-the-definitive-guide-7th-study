![](https://velog.velcdn.com/images/ninto_2/post/1a76d999-dfe9-4e17-9076-8001518529ab/image.png)

<h2 id='1'>📌 객체 Object </h2>

> **객체는 프로퍼티의 순서 없는 집합체이며 각 프로퍼티에는 이름(key)과 값(value)이 있다.**

**객체는 자바스크립트의 가장 기본적인 데이터 타입이며 복합된 값이다.**
`자바스크립트에선 원시타입을 제외한 모든 값을 전부 객체라고 본다.`

여기에서 말하는 복합된 값이란, 여러가지의 값(기본 값이나 다른 객체)을 모아서 **이름을 통해 값을 저장하고 가져올 수 있다는 의미이다.**

객체는 단순히 이름과 값을 연결하는 것이 아니다. 자신만의 프로퍼티를 가지는 것 외에도 `프로토타입으로 다른 객체에서 프로퍼티를 상속`하기도 한다.

**객체의 메서드는 일반적으로 상속된 프로퍼티**이며 **프로토타입 상속이 자바스크립트의 중요한 기능**이다.

만약 상속되지 않은 프로퍼티가 있다면 이를 자체 프로퍼티(own property)라고 부른다.

**객체의 프로퍼티**에는 이름과 값이 있으며, 대표적으로 세 가지의 프로퍼티 속성(쓰기, 열거, 변경 가능)이 있다.

> `※ 자바스크립트 내장 객체의 프로퍼티 중 상당수는 읽기 전용이거나, 열거&변경 불가 기능이다.`

- **프로퍼티 이름**에는 빈 문자열과 심벌을 포함해 어떤 문자열이든 사용 가능하지만, `같은 이름의 프로퍼티는 존재 할 수 없다.`
- **프로퍼티 값**은 타입을 가리지 않는 자바스크립트의 값이며, getter 나 setter 또는 둘 다가 될 수 있다.

객체는 동적(가변)이기 때문에 일반적으로 프로퍼티를 추가하거나 삭제할 수 있지만, 정적인 객체를 흉내 낼 수 있고 정적 타입을 사용하는 언어의 구조 역시 사용할 수 있다.

객체는 값이 아닌 **참조로 조작**을 한다.

```
const obj = {
	name: 'kim'
}

let a = obj;
let b = a;

b.age = 20; //변수 b를 통해 obj를 조작

console.log(a.age); // 20
console.log(obj); // {name: 'kim', age: 20}

```

객체를 수정하게 되면 같은 참조를 하고 있는 모든 대상에게 똑같은 수정 결과가 반영된다.

아래에서 조금 더 자세하게 객체의 `리터럴 문법과 생성, 검색, 설정, 삭제, 테스트, 프로퍼티 열거`에 대해 알아보고 `확장, 직렬화, 메서드 정의`에 대해 자세히 살펴보자.

<br>

---

## 프로토타입 이란 무엇일까

**객체의 조작 방법을 알기전에 먼저 프로토타입이라는 개념을 알고있어야 한다.**

자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있는데
이 부모 객체를 프로토타입이라고 한다.

```
const crew = {
    name: 'kim',
    screening: 'front',
}
```

이 코드를 실행하면 내부적으로 crew는 Object 생성자 함수에 의해 생성된다.
이때 crew는 `crew.__proto__`라는 내부 링크를 통해 Object 함수가 미리 가지고 있던 Object.prototype과 연결된다.
이 Object.prototype을 프로토타입 객체라고 한다.

<br>

---

## 프로토타입 체인은 무엇일까

![](https://velog.velcdn.com/images/ninto_2/post/69319dad-7199-4cba-9565-d6e7c8645258/image.png)

```
const array = [];
array.hasOwnProperty('hasOwnProperty') === false
array.hasOwnProperty('length') === true
```

이 코드를 보면 array에는 hasOwnProperty메서드가 없다.
하지만 에러없이 사용이 가능하다. 그 이유는 무엇일까?

자바스크립트 엔진은 먼저 array 객체에 해당 프로퍼티가 존재하는지 확인한다.
하지만 존재하지 않으므로 내부 링크(`__proto__`)를 통해 Array.prototype으로 접근한다.
마찬가지로 Array.prototype에 해당 메서드가 있는지 확인한다.
하지만 존재하지 않으므로 내부 링크(`__proto__`)를 통해 Object.prototype으로 접근한다.
Object.prototype에는 해당 메서드가 존재하므로 결과적으로 array는
`Object.prototype.hasOwnProperty`를 사용하게 되는 것이다.

위 과정과 같이 어떤 객체에 특정 프로퍼티나 메서드에 접근할 때
특정 프로퍼티나 메서드가 없다면 내부링크를 통해 상위 프로토타입으로 접근하려는 행위를 프로토타입 체인이라고 부른다.
array 객체뿐만 아니라 자바스크립트의 모든 객체의 프로토타입체인은 Object.prototype에서 끝나게 된다.
즉, Object.prototype은 프로토타입 체인의 종점이라고 한다.

<br>

---

## constructor 프로퍼티

프로토타입에는 constructor라는 프로퍼티가 존재한다. 이 프로퍼티의 기능은 무엇일까?
이름에서 느껴지듯 자신을 생성한 생성자 함수를 가리키는 역할을 한다.
Object.prototype에는 constructor 프로퍼티가 숨겨져 있는데, Object의 prototype으로 연결된다.

```
Object.prototype.constructor === Object //true

crew.constructor === Object //true
```

어떤 원리 구동 방식으로 crew.constructor가 Object를 가리키는지 이해할 필요가 있다.
그 답은 바로 프로토타입 체인에 있다.
array 객체가 hasOwnProperty 메서드를 사용할 때 프로토타입 체인이라는 흐름으로 `Object.prototype.hasOwnProperty`를 사용한다는 것을 알게되었다.
constructor프로퍼티도 마찬가지로 프로토타입 체인을 통해 `Object.prototype.constructor`를 사용하는 것이다.
즉, `crew.constructor`는 내부적으로 `crew.__proto__.constructor`를 가리키게 되어 Object를 가리키게 되는 것이였다.

이처럼 `Object.prototype`, `Object.prototype.constructor`, `crew.__proto__`로 맺어진 관계를 삼각편대라고 지칭한다.

<br>

---

## 함수 에서의 프로토타입

다음으로 `Funtion.prototype`과 `(function(){}).prototype` 에서의 프로토타입을 알아보자.
화살표 함수를 제외한 자바스크립트의 모든 함수 생성은 Function 생성자함수를 통해 이루어진다.

```
function sum(a, b) {
  return a + b;
}

var sum = new Function('a', 'b', 'return a + b');
```

즉 이 코드가 내부적으로는 function 생성자함수를 통해 동작한다는 것을 의미한다.
여기서 `sum.__proto__`는 Function.prototype을 가리키게 되는데 그 이유는 무엇일까?
그 이유는 삼각편대를 떠올리면 이해가 쉽다.
결국 sum 함수도 Function생성자 함수를 통해 생성된 함수 객체이기 때문에 삼각편대 구조가 만들어지게 된다.
하지만 함수 객체는 일반 객체와는 다르게 또 다른 특징이 하나 존재한다.
바로 프로토타입 프로퍼티(`__prototype__`)를 가지고 태어난다는 점이다.

```
function Crew(name) {
  this.name = name;
}
const foo1 = new Crew('foo1');
const foo2 = new Crew('foo2');
```

Crew 생성자 함수를 통해 만든 객체들은 공통으로 공유할 수 있는 공간을 지원해주기 위해서 함수객체는 프로토타입 프로퍼티를 가지고 생성이 된다.
이로 인해서 공통 변수 선언 및 메모리 절약의 이점을 가질 수 있게된다.
위 코드에선 2개의 삼각편대가 더 존재한다.
하나는 `Function, Function.prototype, Crew`
또 하나는 `Crew, Crew.prototype, foo1, foo2`이다.

즉 Crew는 Function 생성자 함수를 통해 생성된 함수객체임과 동시에 foo1,foo2를 생성하는 생성자 함수가 된다.
이 삼각편대의 개념이 체화된다면 어떤 객체의 생성자 함수가 무엇인지, 또 프로토타입 체인을 통해 어떤 프로토타입 객체를 거치는지를 구상할 수 있게된다.

![](https://velog.velcdn.com/images/ninto_2/post/e324ef80-1685-4ad1-b7de-4011582156e5/image.png)

- `Object.__proto__`는 무엇일까?
  일단 Object도 결국엔 Object.prototype을 가지는 함수 객체이다.
  그 뜻은 Function 생성자 함수에 의해 생성이 되었단 뜻과 같다.
  즉, `Object.__proto__`는 `Function.prototype`을 가리키게 된다.

- `Function.prototype.__proto__`는 무엇일까?
  답은 `Object.prototype`이다.
  Function.prototype도 결국엔 Object생성자 함수에 의해 생성된 객체이기 때문이다.

위 개념을 살펴보면, 삼각편대가 위아래로 겹쳐진 모습을 확인할 수 있게 된다.
Function이 먼저인지 Object가 먼저인지는 서로 순환참조를 하는 모양이 되어버렸기 때문에 그 답을 알 수가 없다.

<br>

---

## class와 prototype의 차이

클래스는 객체를 생성하려면 설계도, 즉 클래스를 작성해야 한다.

```
class Crew {
  String name;
  Crew(String name) {
    this.name = name;
  }
}
```

위와 같은 Crew 클래스가 있을때 이 클래스는 단순히 설계도이기 때문에 힙 메모리에 존재하지 않는다.
그렇다면 힙 메모리에 존재하게 하려면 어떻게 해야 할까?
바로 이때 new 연산자를 이용하면 된다.

```
class Crew {
  String name;
  Crew(String name) {
    this.name = name;
  }
}
Crew foo = new Foo('foo');
```

반면에 프로토타입은 새로운 객체를 생성해도 Object생성자 함수를 통해 만들게 되기 때문에 Object생성자 함수도 결국은 함수객체이므로 힙 메모리에 존재하는 상태가 된다.
즉, 실제로 존재하는 대상을 통해 객체를 생산하게 된다는 것이다.

또 클래스와 프로토타입의 다른 차이점은 객체의 범주화 개념이 다르다는 점이다.
클래스는 같은 속성을 가지고 있다고 판단되면 같은 범주로 묶을 수 있다.

![](https://velog.velcdn.com/images/ninto_2/post/9b752b11-f04d-41e7-b53e-75ff6b65e78d/image.png)

예를들어 강아지와 고양이가 있다고 생각해보자.
이 둘은 다리 개수, 꼬리 개수, 몸무게 등등의 공통 속성을 가지고 있다.
이 세개의 속성을 가진 설계도(예를들면 동물 클래스)를 작성하여 범주화 할 수 있다.

하지만 프로토타입은 설계도 이런 개념이 없기때문에 실제로 메모리에 존재하는 원형과 비교를 해서 범주화를 한다.
원형이란 각 범주에서 대표할만한 객체를 일컫는 용어이다.

예를들어 새의 범주의 원형에서는 참새가 원형이고, 고양이 범주의 원형에서는 고양이가 원형이라고 가정해보자.
이상태에서 타조의 범주를 매긴다고 했을때 참새와 고양이를 비교해서 더 공통속성이 많은 새의 범주에 들게 된다.

<br>

---

<h2 id='2'>📌 객체 생성</h2>

객체를 생성할 때는 다양한 방법이 존재한다.

**🔗 객체 리터럴**

> 가장 단순한 형태로 ` { 이름 : 값 , }` 의 형태

일반적으로 객체를 생성하는 가장 쉬운 방법은 객체 리터럴을 사용하는 것이다.

```
let empty = {} // 프로퍼티가 없는 빈 객체
let point = { x: 0, y: 0 } //숫자 프로퍼티 2개
let convention = { a: null, }
```

객체 리터럴의 마지막 프로퍼티 뒤에 콤마를 추가하게 되면 나중에 프로퍼티를 추가할 때 문법 에러를 초래할 가능성이 줄어든다.

반복적으로 호출되는 함수나 루프안에 객체 리터럴을 사용하면 새로운 객체를 여러개 만들 수 도 있다.

객체 안에 이름과 값을 변수로 설정해서 외부에서 변에 값을 할당해주어도 해당 객체의 프로퍼티를 추가할 수 있다.
`객체안에서 키를 변수로 받아올땐 bracket을 사용한다.`

```
const key = 'name';
const value = 'kim';

const obj = {
	[key] : value,
}

console.log(obj); // {name: 'kim'}
```

**🔗 new**

> new 연산자는 새 객체를 생성하고 초기화하며, 반드시 뒤에 함수호출이 있어야 한다.

```
// 자바스크립트의 내장 생성자 함수
new Object();
new Array();
new Date();
new Map();

```

이런 형태로 사용하는 함수를 생성자라고 부르며, 새로 생성된 객체를 초기화하는 목적으로 사용한다.

**생성자 함수를 통해서 생성한 객체는 자신을 생성한 생성자 함수의 프로토타입 프로퍼티(`__prototype__`)를 프로토타입으로 갖는다.**

**🔗 Object.creat()**

`Object.creat()`은 첫번째 인자를 프로토타입 삼아 새 객체를 생성한다.

```
let o1 = Object.creat({ x: 1, y: 2}) //o1은 x와 y를 상속한다.
o1.x + o1.y // 3
```

만약 인자로 null을 전달하게 된다면 기본적인 메서드 조차 없다.
객체리터럴이나 new Object()가 반환하는 것 처럼 일반적인 빈 객체를 만들고 싶다면 Object.prototype을 전달해야 한다.

```
let obj = Object.create(Object.prototype); // obj는 {}나 new Object()와 같다.
```

`Object.creat()`을 사용하는 목적 중 하나는 객체를 변경하는 사고를 막는 것이다. 부주의하게 객체의 값을 바꾸더라도 원래 객체에는 아무 영향이 없다.

**🔗 객체 직렬화**

객체 직렬화(serialize)는 객체를 문자열로 변환하는 작업이다.
이 문자열은 나중에 다시 객체로 되돌릴 수 있으며 객체를 문자열로 만들때는 `JSON.stringify()`를 사용하고 되돌릴때에는
`JSON.parse()`를 사용한다.

- JSON은 자바스크립트 객체 표기법의 약어이며 문법은 자바스크립트의 객체와 배열 리터럴과 아주 비슷하다.
- JSON문법은 자바스크립트 문법의 부분 집합이며 자바스크립트 값 전체를 표현하지는 못한다.

<br>

---

<h2 id='9'>📌 객체 메서드</h2>

명시적으로 프로토타입 없이 생성한 객체를 제외하면 자바스크립트 객체는 모두 `Object.prototype`에서 프로퍼티를 상속한다.

**🔗 toString()메서드**

이 메서드에는 인자가 없다. 호출한 객체의 값을 나타내는 문자열로 반환하는 특징을 가지고 있다.

```
let obj = { x: 1, y: 2 }.toString();
obj; // '[object Object]'
```

기본 메서드에서 유용한 정보를 제공하지 않으므로 여러 클래스에서 자신만의 toString을 정의하곤 한다.

- 배열에선 배열 요소 각각을 문자열로 변환한 리스트를 얻고, 함수를 문자열로 변환하면 소스 코드를 얻는다.

**🔗 toLocaleString()메서드**

이 메서드의 목적은 지역에 맞는 문자열 표현을 반환하는 것이다.
하지만 Object에 정의된 기본 toLocaleString() 메서드 자체에는 지역화 기능이 전혀 없고, 그저 toString()을 호출해 그 값을 반환하기만 한다.
Date와 숫자 클래스에는 숫자, 날짜, 시간을 지역의 관습에 맞게 표현하는 toLocaleString()이 있다.
배열의 toLocaleString()는 toString()과 거의 비슷하지만 배열 요소를 변환할때 toLocaleString()를 호출한다는 점이 다르다.

**🔗 valueOf()메서드**

이 메서드는 객체를 문자열이 아닌 다른 기본 타입, 보통은 숫자로 변환하려 할 때 호출한다.
ex. Date 클래스에서의 valueOf()는 날짜를 숫자로 변환한다.
자바스크립트는 기본 값을 예상하는 곳에 객체를 사용하면 자동으로 이 메서드를 호출한다.
point 객체로도 비슷한 일을 수행할 수 있다.

**🔗 toJSON()메서드**

Object.prototype에 실제로 toJSON() 메서드가 정의된 것은 아니지만, JSON.stringify() 메서드는 직렬화할 객체에서
toJSON()메서드를 검색한다. 직렬화할 객체에 이런 메서드가 존재하면 해당 메서드를 호출해 반환 값을 직렬화 한다.

<br>

---

<h2 id='10'>📌 확장된 객체 리터럴 문법</h2>

자바스크립트 최근 버전에서는 객체 리터럴 문법을 여러 가지 방법으로 확장했다.

**🔗 단축 프로퍼티**

ES6 이후에는 아래와 같이 콜론을 생략한 훨씬 간결한 문법을 사용할 수 있다.

```
let num1 = 1, num2 = 2;
let obj = { num1, num2 };
obj.num1 + obj.num2 // 3
```

**🔗 계산된 프로퍼티 이름**

계산된 프로퍼티라는 기능은 말그대로 객체에 사용되어야하는 프로퍼티 이름이 변수에 저장되어 있거나 함수의 반환 값일 경우를 의미한다.
이때에는 객체의 프로퍼티 이름을 대괄호를 사용하여 객체 리터럴 안에 사용하면 해결할 수 있다.

```
const PROPERTY_NAME = 'p1';
function computePropertyName() { return 'p' + 2 };
const p = {
  [PROPERTY_NAME]: 1,
  [computePropertyName()]: 2,
}
p.p1 + p.p2 // 3
```

표현식을 평가한 값을 프로퍼티 이름으로 사용하며, 필요하다면 문자열로 변환한다.
프로퍼티 이름을 직접 쓰기보단 계산된 프로퍼티 문법을 사용하여 프로퍼티 이름 상수를 쓰는 편이 더 안전하다.

**🔗 프로퍼티 이름인 심벌**

ES6이후에는 프로퍼티 이름에 문자열이나 심벌을 사용할 수 있게 되었다.
심벌을 변수나 상수에 할당하면 계산된 프로퍼티 문법을 통해 해당 심벌을 프로퍼티 이름으로 사용할 수 있게 된다.

```
const age = Symbol('age');
const obj = {
  [age] : 20
}
obj // {Symbol(age): 20}
obj.age // undefined
obj[age] // 20
```

심벌을 사용하는 목적은 자바스크립트 객체가 사용할 수 있는 안전한 확장 메커니즘을 정의하는 것이다.
고유한 프로퍼티 이름을 만들때 안성맞춤이다.

**🔗 분해 연산자**

ES2018 이후 객체 리터럴 안에서 분해 연산자`...`를 사용해 기존 객체의 프로퍼티를 새 객체에 복사할 수 있게 되었다.

```
let dimensions = { width: 100, heigth: 75 };
let rect = { ...dimenstions };
rect.width + rect.heigth // 175
```

이런식으로 객체를 다른 객체에 분산하는 용도로 사용하는 것은 객체 리터럴이 유일하다.
분해되는 객체와 프로퍼티를 받는 객체 둘 다 같은 이름의 프로퍼티를 갖는다면 해당 프로퍼티의 값은 마지막에 오는 값이 된다.

분해 연산자는 자체 프로퍼티만 분해할 뿐 상속된 프로퍼티에는 적용되지 않는다.

분해 연산자를 루프나 재귀함수에 넣어 데이터를 큰 객체 하나에 누산한다면 비효율적인 알고리즘을 사용하게 된 다는 점을 주의해야한다.

**🔗 단축 메서드**

객체 안에 메서드를 정의할 때 function 키워드와 콜론을 생략할 수 있다.

```
let square = {
  area() { return this.side * this.side },
  side: 10,
};
square.area() // 100
```

객체 프로퍼티로 정의된 함수를 메서드라고 부른다.
단축 문법을 사용해 메서드를 작성할 때 프로퍼티 이름에는 객체 리터럴 안에 쓸 수 있다면 무엇이든 쓸 수 있게된다.
일반적인 자바스크립트 식별자 외에도 문자열 리터럴, 계산된 프로퍼티 이름, 심벌 역시 사용가능하다.
메서드 이름을 심벌로 사용하게 될 때에는 반드시 심벌 이름 `Symbol.iterator`를 사용해 메서드를 정의해야한다.

**🔗 프로퍼티 게터와 세터**

객체 프로퍼티 대부분은 이름과 값이 있는 데이터 프로퍼티이다.
자바스크립트는 접근자 메서드 게터(getter)와 세터(setter)를 갖는 접근자 프로퍼티 역시 지원한다.

프로그램이 접근자 프로퍼티의 값을 검색하면 자바스크립트는 인자 없이 게터 메서드를 호출한다.
이 메서드의 반환 값이 바로 프로퍼티 접근 표현식의 값이다.

프로그램에서 접근자 프로퍼티의 값을 설정하려 하면 자바스크립트는 세터 메서드를 호출하고, 할당 표현식의 오른쪽 값을
인자로 전달한다.

이 메서드가 프로퍼티 값 세팅을 담당하는 것이다.(세터 메서드의 반환 값은 무시)

- 프로퍼티에 게터와 세터 메서드가 모두 있으면 해당 프로퍼티는 읽기와 쓰기가 모두 가능한 프로퍼티이다.
- 게터 메서드 하나만 있다면 읽기 전용 프로퍼티이다.
- 세터 메서드 하나만 있다면 쓰기 전용 프로퍼티이다.(데이터 프로퍼티에는 불가능)
  - 값을 읽으려 하면 항상 undefined로 평가된다.

접근자 프로퍼티는 객체리터럴 문법의 확장으로 정의할 수 있다.
`다른 ES6 확장과 달리, 게터와 세터는 ES5에서 도입되었다.`

접근자 프로퍼티는 한 개 혹은 두 개의 메서드 형태로 정의되며, 그 이름은 프로퍼티 이름과 같다.
앞에 get과 set을 붙인다는 것 외에는 ES6 단축 문법으로 정의된 일반적인 메서드와 별로 다르지 않다.
