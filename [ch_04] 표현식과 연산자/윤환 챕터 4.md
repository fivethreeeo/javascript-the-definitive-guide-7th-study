# 4. 표현식과 연산자

# 4.1 기본 표현식

**JS의 기본 표현식**

단독으로 존재, 자신보다 더 단순한 표현식 포함 X

상수, 리터럴 값, 일부 키워드, 변수 참조

1. 리터럴 : 문자 그대로 쓰는 값

```jsx
1.23// 숫자 리터럴
"hello" // 문자열 리터럴
/pattern/ // 정규 표현식 리터럴
```

1. JS 예약어

```jsx
true // 불 true로 평가됩니다.
false // 불 false로 평가됩니다.
null // null로 평가됩니다.
this // '현재' 객체로 평가됩니다.
```

this 키워드는 객체 지향 프로그래밍에서 사용

1. 변수, 상수, 전역 객체의 프로퍼티에 대한 참조 형태

```jsx
i // 변수 i의 값으로 평가됩니다.
sum // 변수 sum의 값으로 평가됩니다.
undefined // 전역 객체의 ’’undefined" 프로퍼티 값
```

# 4.2 객체와 배열 초기화 표현식

**초기화 표현식(initializer)**

그 값이 새로 생성된 객체나 배열인 표현식

객체 리터럴이나 배열 리터럴이라고 부름

리터럴과 달리 기본 표현식은 아님

**배열 리터럴**

콤마 사이의 값을 생략하면 정의되지 않은 요소가 그 자리에 들어감. 

예를 들어 다음 배열은 요소가 다섯 개 있는데 그중 세 개는 정의되지 않음
`let sparseArray = [1,,,,5];`

**객체 리터럴**

대괄호 대신 중괄호를 쓰고 각 하위 표현식은 프로퍼티 이름과 콜론(：)으로 시작

```jsx
let p = { x: 2.3, y: -1.2 }; // 프로퍼티가 두 개 있는 객체
let q = {}; // 프로퍼티가 없는 빈 객체
q.x = 2.3; q.y = -1.2; // 이제 이의 프로퍼티는 하의 프로퍼티와 같습니다.
```

# 4.3 함수 정의 표현식

함수 정의 표현식을 **‘함수 리터럴’** 이라고 함

```jsx
// 이 함수는 전달받은 값의 제곱을 반환합니다.
let square = function（x） { return x * x; };
```

ES6 이후에서는 함수 표현식을 간결한 ‘화살표 함수’ 문법으로 사용 가능

# 4.4 프로퍼티 접근 표현식

프로퍼티 접근 표현식은 객체 프로퍼티나 배열 요소의 값으로 평가

1. 첫 번째 스타일은 표현식 뒤에 마침표를 쓰고 그 뒤에 식별자를 쓰기
    
    `expression . identifier` 
    
2. 표현식（객체나 배열） 뒤에 대괄호를 쓰고 그 안에 다른 표현식을 쓰는 형태
    
    `expression [ expression ]`
    

프로퍼티 이름에 스페이스나 구두 점이 들어 있거나, 

숫자인 경우（배열）에는 반드시 대괄호 표기법 사용

## 4.4.1 조건부 프로퍼티 접근

ES2020에서 새로운 프로퍼티 접근 표현식 두 가지를 추가

`expression ?. identifier` 

`expression ?.[ expression ]`

왼쪽에 있는 표현 식이 null이나 undefined로 평가될 때 TypeError 발생

. ?.과 ?. [] 문법을 사용해 에러 막기

⇒a가 null이거나 undefined라면 이 표 현식은 프로퍼티 b에 접근하려는 시도 없이 undefined로 평가

이런 형태의 프로퍼티 접근 표현식을 ‘옵션 체인’ 부름

# 4.5 호출 표현식

**호출 표현식**

함수나 메서드를 호출(실행)하는 문법

```jsx
Math.max(x,y,z) // Math.max는 함수이고 x, y, z는 인자입니다. 
a.sort() // a.sort는 함수이고 인자는 없습니다.
```

함수 표현식의 값이 함수가 아니라면 TypeError 발생

return 문을 사용해 값을 반환한다면 그 값이 호출 표현식의 값

호출 표현식 맨 앞에 있는 표현식이 프로퍼티 접근 표현식이라면 이 호출은 메서드 호출

## 4.5.1 조건부호출

ES2020의 조건부 호출 문법을 쓰면 ?. ()를 사용해 함수를 호출

```jsx
function square(x, log) { // 두 번째 인자는 선택 사항인 함수입니다.
	log?.(x); // 함수를 받았으면 호출합니다.
	return x * x; // 인자의 제곱을 반환합니다.
}
```

?.()는 왼쪽에 있는 것이 null이나 undefined인지만 체크

# 4.6 객체 생성 표현식

객체 생성 표현식은 객체를 생성하고 함수(생성자)를 호출해 객체 프로퍼티를 초기화

```jsx
new Object()
new Point(2,3)
```

객체 생성 표현식의 값은 새로 생성된 객체

# 4.7 연산자 개요

## 4.7.1 피연산자개수

연산자는 예상하는 피 연산자 개수(항(arity))를 기준으로 분류 가능

ex)

 3항 연산자:  `?：` 표현식 세 개를 하 나로 바꾸는  조건 연산자

## 4.7.2 피연산자와 결과 타입

JS 연산자는 필요에 따라 피연산자의 타입을 변환

피 연산자 타입 에 따라 다르게 동작하는 연산자

`+` : 피 연산자가 숫자이면 더하고, 문자열이면 병합

`<`:피 연산자 타입에 따라 숫자 순서로도, 알파벳 순서로도 비교

## 4.7.3 연산자와 부수 효과

일부 표현식에는 이후의 평가 결과에 영향을 미치는 부수 효과（side effect)  존재

**할당 연산자**

해당 변수나 프로퍼티 를 사용하는 모든 표현식에 영향

증가 연산자 `++`와 감소 연산자 `--` 는 묵시적으로 할당의 역할

`delete` 연산자 : 프로퍼티를 삭제하는 것은 해당 프로퍼티에 undefined를 할 당하는 것과 비슷

## 4.7.4 연산자 우선순위

곱셈과 나눗셈은 덧셈 과 뺄셈보다 우선순위가 높음

할당은 우선순위가 아주 낮으며 거의 항상 마지막에 수행

typeof 연산자는 우선순위가 가장 높은 연산자 중 하나이지만, 

typeof 동작은 프로퍼티 접근, 배열 인덱스, 함수 호출 다음에 수행

## 4.7.5 연산자 결합성

**결합성은 우선순위가 같은 동작을 수행할 때의 순서**

왼쪽에서 오른쪽으로 연산 하는 좌결합성

오른쪽에서 왼쪽으로 연산하는 우결합성

지수, 단항, 할당, 조건（3항） 연산자는 오른쪽에서 왼쪽으로 수행

## 4.7.6 평가 순서

평가 순서는 평가하는 표현식에 다른 표현식의 값에 영향을 미치는 부수 효과가 있을 때에만 유의미

# 4.8 산술 표현식

기본 산술 연산자에는 

**（지수）, *（곱셈）, /（나눗셈）, %（나머지）, +（덧셈）, -（뺄셈）

자바스크립트에서는 모든 숫자가 부동 소수점이므로 나눗셈의 결과 역시 항상 부동 소수점

0을 0으로 나누 면 NaN

## 4.8.1 +연산자

숫자 피 연산자는 더하고 문자열 피 연산자는 병합

```jsx
1+ 2  //=> 3
"hello" + " " + "there" // => "hello there" 
"1" + "2" // => "12"
```

```jsx
"1" + 2 // => "12": 숫자를 문자열로 변환한 후 병합
2 + null // => 2: null을 0으로 변환한 후 덧셈
2 + undefined // => NaN: undefined를 NaN으로 변환한 후 덧셈
```

+ 연산자의 피 연산자가 문자열과 숫자일 때 그 연관성은 명확하지 않음

즉, 동작 순서 에 따라 결과가 달라질 수 있음

```jsx
1 + 2 + " blind mice" // => "3 blind mice"
1 + (2 + " blind mice") // => "12 blind mice"
```

## 4.8.2 단항 산술 연산자

단항 연산자는 피 연산자 하나의 값을 바꿔 새 값을 얻음

**단항 플러스(+) , 단항 마이너스(-)**

피 연산자를 숫자(또는 NaN)로 변환한 값을 반환

**증가 (++), 감소 （一）**

 피 연산자에 1을 더하거나 뺌 , 그 피 연산자는 반드시 왼쪽 값

피 연산자의 앞에 있을 때 이를 전위 증가 연산

피 연산자의 뒤에 있을 때 이를 후위 증가 연산자

## 4.8.3 비트 연산자

숫자의 이진 표현의 비트를 대상으로 저수준 조작을 수행

NaN. Infinity, -Infinity에 시프트 연산자를 적용한 결과는 모두 0

**비트 AND(&)**

& 연산자는 피 연산자인 정수의 각 비트에 불 AND 연산을 수행

**비트 OR(I)**

I 연산자는 피연산자인 정수의 각 비트에 불 OR 연산을 수행

**비트 XOR(^)**

^ 연산자는 정수인 피 연산자의 각 비트에 불 XOR 연산을 수행

둘 다 true인 것은 안 된다는 뜻

**비트 NOT(~)**

피 연산 자의 비트를 모두 거꾸로 바꿈

**왼쪽 시프트(<<)**

첫 번째 피 연산자의 비트를 모두 두 번째 피 연산자 값만큼 왼쪽으 로 이동

**부호 붙은 오른쪽 시프트(>>)**

번째 피 연산자의 모든 비트를 두 번째 피 연산자의 숫자(0 이상 31 이하 정수)만큼 오른쪽으로 이동

**0으로 채우는 오른쪽 시프트(>>>)**

첫 번째 피 연산자의 부호와 관계없이 항상 0으로 채운다

부호 붙은 32비트 값을 부 호 없는 정수처럼 취급

# 4.9 관계 표현식

## 4.9.1 일치와 불일치 연산자

== 연산자는 **동등 연산자**라 부르며 , 값을 비교할 때 타입 변환을 허용

### 일치

일치 연산자 ===는 먼저 피 연산자를 평가한 다음, 두 값을 다음과 같이 비교하되, 타입 변환 수행 X

두 값이 모두 null이거나 모두 undefined이면 같은 값

두 값 중 하나라도 NaN이면 같은 값이 아님

두 값이 같은 객체, 배열, 함수를 참조한다면 같은 값

## 4.9.2 비교 연산자

객체를 기본 값으로 변환한 후, 

두 피 연산자가 모두 문자열이라면 두 문자열을 알파벳 순서로 비교

객체를 기본 값으로 변환한 결과,

 문자열이 아닌 피 연산자가 있다면 두 피 연산자를 숫자로 변환한 후 비교

대소문자를 가리지 않고 비교한다면 String.toLowerCase()나 String .totlpperCase()를 사용해 

전부 소문자 또는 대문자로 통일하여 비교

## 4.9.3 in 연산자

`in` 연산자

왼쪽 피 연산자가 오른쪽 객체의 프로퍼티 이름일 경우 true를 반환

```jsx
let point = {x: 1, y: 1};// 객체를 정의합니다.
"x" in point// => true: 객체에는 Nx"라는 프로퍼티가 있습니다.
"z" in point// => false: 객체에는 Hz"라는 프로퍼티가 없습니다.
"toString" in point// => true: 객체는 toString 메서드를 상속합니다.

```

## 4.9.4 instanceof 연산자

`instanceof` 연산자

왼쪽에 있는 객체가 오른쪽에 있는 클래스의 인스턴스 라면 true, 그렇지 않다면 false를 반환

```jsx
let d = new Date(); // DateO 생성자로 객체를 생성합니다.
d instanceof Date// => true: d는 DateO를 통해 생성됐습니다.
d instanceof Object // => true: 객체는 모두 Object의 인스턴스입니다.
d instanceof Number // => false: 어는 Number 객체가 아닙니다.

let a = [1, 2, 3];// 배열 리터럴 문법으로 배열을 생성합니다.
a instanceof Array // => true: a는 배열입니다.
a instanceof Object // => true: 배열은 모두 객체입니다.
a instanceof RegExp// => false: 배열은 정규 표현식이 아닙니다.
```

객체는 모두 Object의 인스턴스

# 4.10 논리 표현식

논리 연산자 &&, ||, !는 불 연산을 수행

## 4.10.1 불 AND(&&)

1. &&를 불 피 연산자와 함 께 사용하면 두 값에서 불 AND 연산을 수행
2. true 같은 값과 false 같은 값 사이에서 불 AND 연산자로 사용된 경우
3. 왼쪽에 있는 값이 true 같은 값이면 && 연산자는 오른쪽에 있는 값을 평가한 후 반환
    
    &&의 이런 동작 방식을 단축 평가(short circuit)라 함
    

## 4.10.2 불 OR (||)

1. 피 연산자 중 하나라 도 true 같은 값이면 이 연산자는 true 같은 값을 반환
2. 첫 번째 피연산자의 값이 true 같은 값이면 단축 평가가 일어나, 오른쪽에 있는 표현식은 평가하지 않고 바로 true 같은 값을 반환

## 4.10.3 불 NOT (!)

단항 연산자 이며, 피 연산자의 불 값을 부정하는(반대로 정하는) 것

# 4.11 할당표현식

= 연산자를 사용해 변수나 프로퍼티 에 값을 할당

하나를 여러 변수에 할당 능

```jsx
i = j = k = 0; // 세 변수를 모두 0으로 초기화
```

## 4.11.1 할당과연산

+= 연산자는 덧셈과 할당을 동시에 수행

```jsx
total += salesTax;
total = total + salesTax;//위 코드는 다음과 동등합니다.
```

# 4.12 평가 표현식

전역 함수 `eval()`

문자열을 자바스크립트 소스 코드로 해석하고 평가해서 값을 얻을 수 있음

```jsx
eval("3+2") // => 5
```

eval()을 사용하고 있다면, 정말로 필요해서 사용하고 있는지 심사숙고해야 함

특히 eval()은 보안 허점을 만듦

## 4.12.1 eval()

eval()은 인자를 하나 받음, 문자열이 아닌 값을 전달하면 그 값을 반환

즉, eval()은 로컬 코드와 같은 방법으로 변수의 값을 검색하고 새로운 변수와 함수를 정의

eval()에 전달하는 코드 문자열은 반드시 그 자체로 문법 에 맞아야 함

## 4.12.2 전역 eval()

간접 호출

즉 직접 호출이 아닌 다른 어떤 형태로 호출한다면,

전역 객체를 변수 환경으로 사용하며 로컬 변수나 함수를 읽거나, 쓰거나, 정의할 수 없음

```jsx
const geval = eval;   // 전역 eval에 다른 이름을 사용합니다.
let x = "global", y = "global";  // 전역 변수 두 개
function f() {  // 이 함수는 로컬에서 eval을 사용합니다.
	let x = "local";  // 로컬 변수를 정의합니다.
	eval("x += 'changed';");  // 직접 호출을 통해 로컬 변수를 수정합니다.
	return x;   // 변경된 로컬 변수를 반환합니다.
}

function g() {  // 이 함수는 전역 eval을 사용합니다.
	let y = "local";  // 로컬 변수
	geval("y += 'changed';"); // 간접 호출이므로 전역 변수에 접근합니다.
	return y;  // 변경되지 않은 로컬 변수를 반환합니다.
}
console.log(f(), x); // 로컬 변수가변경됐습니다. "localchanged global"
console.log(g(), y); // 전역 변수가 변경됐습니다. "local globalchanged"

```

## 4.12.3 스트릭트 eval()

스트릭트 모드

eval() 함수를 더 제한하고, ‘eval’이라는 식별자의 사용 역시 제한

스트릭트 모드에서는 평가된 코드가 로컬 변수를 검색하거나 변경할 수는 있지만,

 로컬 스코프에서 변수나 함수를 새로 정의 X

# 4.13 기타 연산자

## 4.13.1 조건연산자(?：)

조건 연산자

자바스크립트에서 유일한 3항 연산자(피 연산자 세 개)이며, 실제로 3항 연산자라고 부름

```jsx
X > 0 ? X ： -X // X의 절댓값
```

## 4.13.2 null 병합 연산자 (??)

null 병합 연산자

정의된 첫 번째 피연산자로 평가,

왼쪽 피 연산자가 null이나 undefined가 아니면 그 값을 반환

```jsx
let options = { timeout: 0, title: "", verbose: false, n: null };
options.timeout ?? 1000     //0: 객체에 정의된 대로
options.title ?? "Untitled" // "" 객체에 정의된 대로
options.verbose ?? true // false: 객체에 정의된 대로
options.quiet ?? false  //false: quiet 프로퍼티가 정의되지 않았으므로 오른쪽 값
options.n ?? 10 //10: 프로퍼티가 null이므로 오른쪽 값
```

## 4.13.3 typeof 연산자

typeof는 단항 연산자이며 피연산자의 타입을 가리지 않음

값은 피연산자의 타입을 나타내는 문자열

| Type | Result |
| --- | --- |
| Undefined | "undefined" |
| Null | "object" (아래 참고) |
| Boolean | "boolean" |
| Number (en-US) | "number" |
| BigInt (en-US) | "bigint" |
| String | "string" |
| Symbol (ECMAScript 2015에서 추가) | "symbol" |
| 호스트 객체 (JS 환경에서 제공) | 구현체마다 다름 |
| Function 객체 (ECMA-262 표현으로는 [[Call]]을 구현하는 객체) | "function" |
| 다른 모든 객체 | "object" |

## 4.13.4 delete 연산자

`delete`

피 연산자로 지정된 객체 프로퍼티나 배열 요소를 삭제하는 단항 연산자

```jsx
let a = [1,2,3]; // 이 배열로 시작합니다.
delete a[2];  // 배열의 마지막 요소를 삭제합니다.
2 in a  // => false: 인덱스 2에 해당하는 요소는 이제 존재하지 않습니다.
```

프로퍼티를 삭제하면 해당 프로퍼티가 더는 존재하지 않음

스트릭트 모드에서 delete에 피 연산자로 변수, 함수, 함수 매개변수 같은 유효하지 않은（unqualified） 식별자를 넘기면 SyntaxError

## 4.13.5 await 연산자

`await` 

비동기 연산을 나타내는 프라미스 객체를 피 연산자로 예상하고, 

프로그램이 마치 그 비동기 연산이 끝나길 기다리는 것처럼 동작

## 4.13.6 void 연산자

`void`

 단항 연산자이며 피 연산자 타입을 가리지 않음

void는 피 연산자를 평가한 후 그 값을 버 리고 undefined를 반환

## 4.13.7 콤마 연산자 （,）

콤마 연산자

2항 연산자이며 피연산자의 타입을 가리지 않음

왼쪽 피 연산자를 평가하고, 오른쪽 피 연산자를 평가한 후 오른쪽 피 연산자의 값을 반환